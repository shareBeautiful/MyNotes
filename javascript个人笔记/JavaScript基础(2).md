title: JavaScript基础(2)
tags:
  - JavaScript
categories:
  - JavaScript
author: ''
date: 2017-08-29 10:27:00
---
# JavaScript中的执行细节
---

> 
- [x] 全局作用域
- [x] 全局变量
- [x] 函数作用域
- [x] 执行环境栈(执行上下文栈ECS)
- [x] 执行环境(执行上下文EC)
- [x] 变量对象(VO),活动对象(AO)
- [x] 作用域，作用域链,变量声明

## 执行环境栈(ECS)：
> 
包括 全局执行环境 和 函数执行环境
当JavaScript代码执行的时候，会进入不同的执行上下文，
这些执行上下文就构成了一个执行上下文栈（Execution context stack，ECS）
栈底总是全局上下文，栈顶是当前（活动的）执行上下文
先进后出：
压栈：全局EC-->局部EC1-->局部EC2-->当前EC
出栈：全局EC<--局部EC1<--局部EC2<--当前EC

## 执行环境(EC):
分为3中，全局，函数，eval
每个执行环境EC都有三个重要的属性被创建：
> 
变量对象（Variable object，VO),
作用域链（Scope chain）
this 的指向确定

> 
1. 执行环境（execution context），也叫执行上下文，
每个函数都会有自己的执行环境；当浏览器首次加载脚本时，
他将默认进入全局执行环境；如果接下来要调用一个内部函数，则创建一个新的执行环境，
并将新建的执行环境压入执行环境栈（execution context stack）的顶部，在函数执行之后，栈将其环境弹出，控制权返回给之前的执行环境。
当代码在一个环境中执行时，
2. 每个执行环境都有一个与之关联的变量对象（variable object），
环境中定义的所有变量和函数都保存在这个对象中。
然后每进入一个执行环境，这个变量对象就被激活变成活动对象 （activation object），
就可以被访问到了。当代码在一个环境中执行时，会创建变量对象的一个作用域链，
作用域链作用是保证对执行环境有权访问的所有变量和函数的有序访问。
3. 执行环境的建立：
创建(进入)：创建作用域链，创建变量对象(参数，函数声明，变量声明)和this的值。
执行：初始化变量的值和函数引用，执行代码。
```javascript

  EC={
    Scope:{ /* VO以及所有父执行上下文中的VO */},
    VO:{/* 函数中的arguments对象, 参数, 内部的变量以及函数声明 */ },
    this:{}
  }
```
4. 变量对象初始化顺序：函数形参 --> 函数声明 --> 变量声明；（也是提升顺序）
① 函数声明过程中如果变量对象已经包含了相同名字的属性，则替换它的值；
② 变量声明过程中如果变量名和已经声明的函数名或者函数的参数名相同，则不会影响已经存在的属性。
```javascript
(function() {
  console.log(typeof a); // 'function'
  console.log(typeof b); // 'undefined'

  var a = 'a';
  var b = function() {
  console.log('b')
};
function a() {
  console.log('c')
}
}());
```

### 变量对象VO ：是与执行上下文相关的数据作用域 分为 2 个阶段：创建 和 执行
> 
包括定义的 变量，函数声明，和函数的参数
全局对象 === 全局中的变量对象
当JavaScript代码运行中，如果试图寻找一个变量的时候，就会首先查找VO
VO特殊情况：函数表达式（与函数声明相对）不包含在VO之中
没有使用var声明的变量（这种变量是，"全局"的声明方式，
只是给Global添加了一个属性，并不在VO中）

### AO：只有全局上下文的变量对象允许通过VO的属性名称间接访问；
> 
在函数执行上下文中，VO是不能直接访问的，
此时由激活对象(Activation Object,缩写为AO)扮演VO的角色。
包括 callee,length,props(当前函数的引用,参数个数,参数)
AO是在进入函数的执行上下文时创建的，并为该对象初始化一个arguments属性，该属性的值为Arguments对象。

### [[scope]]:
> 
JS引擎还要创建一个与EC关联的全局变量对象(Varibale Object) VO,  并把VO指向全局对象，VO中不仅包含了全局对象的原有属性，还包括在全局定义的变量x 和函数 A，与此同时，在定义函数A的时候，还为 A 添加了一个内部属性scope，并将scope指向了 VO。
每个函数在定义的时候，都会创建一个与之关联的scope属性，scope总是指向定义函数时所在的环境。

> 
[[Scope]]是一个包含了所有上层变量对象的分层链，它属于当前函数上下文，并在函数创建的时候，保存在函数中。
[[Scope]]是在函数创建的时候保存起来的——静态的（不变的），只有一次并且一直都存在——直到函数销毁。
比方说，哪怕函数永远都不能被调用到，[[Scope]]属性也已经保存在函数对象上了。
Scope是EC的属性，而[[scope]]则是函数的静态属性。


#### scope和[[scope]]:
Scope是EC的属性，而[[scope]]则是函数的静态属性。

```javascript

exampelEC = {
  Scope:[
    f2Context.AO+f2.[[scope]],
    f1.context.AO+f1.[[scope]],
    globalContext.VO
  ]
}
```
> 
当一段JavaScript代码执行的时候，JavaScript解释器会创建Execution Context，

> 
其实这里会有两个阶段：
创建阶段（当函数被调用，但是开始执行函数内部代码之前）

1. 创建Scope chain
> 创建VO/AO（variables, functions and arguments）

2. 设置this的值
3. 激活/代码执行阶段
> 设置变量的值、函数的引用，然后解释/执行代码

## 作用域和作用域链：
在js中除了全局作用域，只有函数作用域，函数的作用域是在函数定义时候决定的不是执行调用决定的，定义函数时同时创建 [[scope]]属性指向VO或AO对象，而VO/AO中存放的是上一级的作用域包括变量，函数，参数...，因此，函数在执行时候创建EC进入ECS顶端并执行，在查找变量时，先从自身的AO开始查找，沿着[[scope]]属性指向的变量对象查找，直到全局变量对象中没找到，返回undefine作用域链实际上就是自下而上地将所有嵌套定义的上下文所绑定的变量对象AO串接到一起

作用域链与一个执行上下文相关，是内部上下文所有变量对象（包括父变量对象）的列表
> Scope = VO/AO + All Parent VO/AOs

> 
作用域是一套规则在 js 编译的时候确定的不是再执行的时候确定的，作用域链是作用域的实现，是js在执行的时候确定的包括自身的VO和上级的VO

> 
总结：作用域链Scope其实就是对执行上下文EC中的变量对象VO|AO有序访问的链表。能按顺序访问到VO|AO，就能访问到其中存放的变量和函数的定义。其中，AO始终在Scope的最前端，不然为啥叫活跃对象呢。
                      
## this:属于EC执行环境中的对象，指向调用函数时所属的对象
1. 全局中的this
2. 函数中的this
3. 对象中的this
4. 构造函数中的this
5. 原型中的this
6. call,apply,bind改变this
> 
如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。
如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，
当this指向undefined时，它会被自动指向全局对象。

> 
当obj在全局声明时，无论obj.c在什么地方调用，这里的this都指向全局对象，
而当obj在函数环境中声明时，这个this指向undefined，在非严格模式下，
会自动转向全局对象。
```javascript
'use strict';
var a = 20;
function foo () {
  var a = 1;
  var obj = {
    a: 10, 
    c: this.a + 20,
    fn: function () {
    return this.a;
  }
}
return obj.c;

}
console.log(foo()); // 运行会报错
```
## 闭包：
当函数可以记住并访问所在的作用域(全局作用域除外)时，就产生了闭包，即使函数是在当前作用域之外执行。

在函数内部创建新的函数；
新的函数在执行时，访问了函数的变量对象；
```javascript

    var fn = null;
    function foo() {
        var a = 2;
        function innnerFoo() { 
            console.log(a);
        }
        fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn
    }
    function bar() {
        fn(); // 此处的保留的innerFoo的引用
    }
    foo();
    bar(); // 2
    
```
> 
1.  闭包是在函数被调用执行的时候才被确认创建的。
2.  闭包的形成，与作用域链的访问顺序有直接关系。
3.  只有内部函数访问了上层作用域链中的变量对象时，才会形成闭包，因此，我们可以利用闭包来访问函数内部的变量。
4. chrome中理解的闭包，与《你不知道的js》与《JavaScript高级编程》中的闭包理解有很大不同


## 函数与函数式编程
> 
函数声明、函数表达式、匿名函数与自执行函数

> 
函数声明
我们知道，JavaScript中，有两种声明方式，
一个是使用var的变量声明，另一个是使用function的函
        
## 数声明。
### 函数表达式
与函数声明不同，函数表达式使用了var进行声明
### 匿名函数
就是指的没有被显示进行赋值操作的函数。
### 函数自执行(IIFE)与块级作用域
在ES5中，没有块级作用域，因此我们常常使用函数自执行的方式来模 
仿块级作用域，这样就提供了一个独立的执行上下文，结合闭包，就为模块化提供了基础。
> 
1. (function(){})()
2. !function(){}()
3. +function(){}()

## js中的垃圾收集
> JavaScript中具有自动垃圾收集机制，垃圾收集器会按照固定的时间和间隔运行

### 垃圾收集 2 种算法：
> 
1.执行流进入执行环境时，就把所有变量标记为清除
执行流进入执行环境时，就把所有变量标记为 "进入环境"，当变量离开环境时
就标记为 "离开环境"
然后它会去掉环境中的变量和环境中的变量引用的变量的标记。而被标记的变量
将被视为准备删除的变量，然后，垃圾收集器完成内存清除工作，释放内存。

> 
2.引用计数
按值被引用的次数为0，就被清除，不为0就不会垃圾收集(内存泄漏)。
引用计数存在 循环引用的问题，在ie中dom的操作最为明显